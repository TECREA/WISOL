/******************************************************************************

Welcome to GDB Online.
GDB online is an online compiler and debugger tool for C, C++, Python, PHP, Ruby, 
C#, VB, Perl, Swift, Prolog, Javascript, Pascal, HTML, CSS, JS
Code, Compile, Run and Debug online from anywhere in world.

*******************************************************************************/
#include <stdio.h>
#include <stdint.h>
#include <math.h>


#include "unity.h"
#define MULTIPLICADOR_PF    10000
#define MAX_HORA            24
#define HOURS_TO_SEG         3600
#define MIN_TO_SEG         60
#define APROXIMATION_BELOW  -5000
#define APROXIMATION_ABOVE   5000
typedef struct {
    uint8_t ReportTimeHour;
    uint8_t ReportTimeMinute;
    uint8_t ReportTimeSecond;
    uint8_t ReportTimeDay;
}data_t;
void test_seg_to_h_m_s();

void tiempo(data_t * report ,uint32_t data);
data_t datos;

int main()
{

 /*printf("hhp ReportTimeHour = %d  ReportTimeMinute = %d  ReportTimeSecond = %d ---aux :%f",ReportTimeHour , ReportTimeMinute ,ReportTimeSecond , aux);*/
  


    UNITY_BEGIN();
    RUN_TEST(test_seg_to_h_m_s);
    return UNITY_END();

   /* return 0;*/
}

void test_seg_to_h_m_s(){
    
    /* Test 1 -----------------------------------------------*/
/*float num = 4.3;
float a = (num > 0)? 0.5 :-0.5;
printf("hola %d \r\n",( (int)( num + a) ) );
*/
tiempo(&datos,21670);

   TEST_ASSERT_EQUAL_UINT8(6,datos.ReportTimeHour);
    TEST_ASSERT_EQUAL_UINT8(1,datos.ReportTimeMinute);
    TEST_ASSERT_EQUAL_UINT8(10,datos.ReportTimeSecond);

    tiempo(&datos,650);
    TEST_ASSERT_EQUAL_UINT8(0,datos.ReportTimeHour);
    TEST_ASSERT_EQUAL_UINT8(10,datos.ReportTimeMinute);
    TEST_ASSERT_EQUAL_UINT8(50,datos.ReportTimeSecond);
   
    tiempo(&datos,65535);
    TEST_ASSERT_EQUAL_UINT8(18,datos.ReportTimeHour);
    TEST_ASSERT_EQUAL_UINT8(12,datos.ReportTimeMinute);
    TEST_ASSERT_EQUAL_UINT8(15,datos.ReportTimeSecond);

    tiempo(&datos,86400);
    TEST_ASSERT_EQUAL_UINT8(24,datos.ReportTimeHour);
    TEST_ASSERT_EQUAL_UINT8(0,datos.ReportTimeMinute);
    TEST_ASSERT_EQUAL_UINT8(0,datos.ReportTimeSecond);
  
   
    tiempo(&datos,604800);
    TEST_ASSERT_EQUAL_UINT8(168,datos.ReportTimeHour);
    TEST_ASSERT_EQUAL_UINT8(0,datos.ReportTimeMinute);
    TEST_ASSERT_EQUAL_UINT8(0,datos.ReportTimeSecond);

    tiempo(&datos,2592070); /*Segundos*/
    TEST_ASSERT_EQUAL_UINT8(720,datos.ReportTimeHour);
    TEST_ASSERT_EQUAL_UINT8(1,datos.ReportTimeMinute);
    TEST_ASSERT_EQUAL_UINT8(10,datos.ReportTimeSecond);
}
void tiempo(data_t * report ,uint32_t data){
    uint64_t aux,aux2,A;
    aux =  data >= HOURS_TO_SEG ? ( (uint64_t)data*MULTIPLICADOR_PF/HOURS_TO_SEG) : (uint64_t)data*MULTIPLICADOR_PF/MIN_TO_SEG;
	 report->ReportTimeHour =  data >= HOURS_TO_SEG ? aux / MULTIPLICADOR_PF : 0;
     A =  ( (aux - report->ReportTimeHour*MULTIPLICADOR_PF) *MIN_TO_SEG);
     report->ReportTimeMinute =    data >= MIN_TO_SEG ? ( data >= HOURS_TO_SEG ? A /MULTIPLICADOR_PF : (aux/ MULTIPLICADOR_PF) ) : 0;
     aux2 = report->ReportTimeHour > 0 ? ( ( A  - report->ReportTimeMinute*MULTIPLICADOR_PF)*MIN_TO_SEG) : ((aux - report->ReportTimeMinute*MULTIPLICADOR_PF)*60 ) ;
     report->ReportTimeSecond =  aux2 > 0 ? ( aux2 +  ( (aux2 > 0)? APROXIMATION_ABOVE : APROXIMATION_BELOW) ) / MULTIPLICADOR_PF : 0;
}

/*if(report->ReportTimeHour > 24){ report->ReportTimeDay = report->ReportTimeHour / 24}*/


 /* 
    float aux,aux2;
    aux = data >= 3600 ? (data/3600.0) : data/60.0;
	 report->ReportTimeHour =  data >= 3600 ? (uint8_t)aux : 0;
     report->ReportTimeMinute =    data >= 60 ? ( data >= 3600 ? (uint8_t)( (aux - report->ReportTimeHour) *60) : (uint8_t)(aux ) ) : 0;
     aux2 = report->ReportTimeHour > 0 ?(  ((aux - report->ReportTimeHour)*60 - report->ReportTimeMinute)   )*60 : ((aux - report->ReportTimeMinute)*60 ) ;
     aux2 += (aux2 > 0)? 0.5 : -0.5;
     report->ReportTimeSecond =  (int)aux2;
*/